# 持久化
## RDB：快照

### save
持久化的时候redis服务阻塞

### bgsave

fork( ) + copyonwrite 实现异步 + 非阻塞

- 主进程fork()子进程之后，内核把主进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向主进程（共享了 fork 瞬间主进程的内存）
- 主进程写内存时，触发页异常中断，陷入内核中断
- 内核把**触发的异常**的页复制一份，于是主子进程各自持有独立的一份数据页（其余的页共享主进程）
- 主进程在复制的页上进行数据修改，然后引用修改后的数据页；子进程使用原数据页



## AOF

每次执行 **修改内存** 中数据集的写操作时，都会追加 **记录** 该操作。

AOF 日志是以文件的形式存在的，当程序对 AOF 日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回到磁盘。默认每秒使用 fsync **强制从内核缓存刷到磁盘**。

### 重写

AOF文件大小超过阈值后，启动子进程，对AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

**AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。**

为了解决子进程在进行 AOF 重写期间数据状态不一致，创建 **AOF 重写缓冲区**，当Redis服务器执行一个写命令之后，就会将这个写命令也发送到 AOF 重写缓冲区。当子进程完成 AOF 重写之后，就会给父进程发送一个信号，父进程接收此信号后，将 AOF 重写缓冲区的内容都写到新的 AOF 文件中。

## 混合持久化

先加载 `rdb` 的内容，然后再重放增量 AOF 日志