# Redis 事务

## 事务

MULTI, EXEC, DISCARD and WATCH 是Redis事务的基础。`用来显式开启并控制一个事务，它们允许在一个步骤中执行一组命令`。并提供以下保证：

- 事务中的所有命令都会被序列化并按顺序执行。在执行Redis事务的过程中，不会出现由另一个客户端发出的请求。这保证 `命令队列` 作为一个单独的原子操作被执行
- 队列中的命令要么全部被处理，要么全部被忽略。EXEC命令触发事务中所有命令的执行，因此，当客户端在事务上下文中失去与服务器的连接
- 如果发生在调用MULTI命令之前，则不执行任何`commands`
- 如果在此之前EXEC命令被调用，则所有的`commands`都被执行

## 用法

使用`MULTI`命令`显式开启`Redis事务。**此时用户可以发出多个命令，Redis不会执行这些命令，而是将它们排队**。`EXEC`被调用后，所有的命令才会被执行。而调用`DISCARD`可以清除事务中的`commands队列`并退出事务。

## 错误

从`Redis 2.6.5开始`，服务端会记住在累积命令期间发生的错误，当`EXEC`命令调用时，`将拒绝执行事务，并返回这些错误，同时自动清除命令队列`。**即使事务中的某些命令执行失败，其他命令仍会被正常执行**。

## Redis 事务不支持 Rollback

语法、编译错误大多能被检测，不支持回滚更简单便捷。

## 命令

| 命令        | 格式                    | 作用                                                         | 返回结果                                                     |
| ----------- | ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **WATCH**   | **WATCH key [key ...]** | 将给出的`Keys`标记为`监测态`，作为事务执行的条件             | always OK.                                                   |
| **UNWATCH** | **UNWATCH**             | 清除事务中`Keys`的 `监测态`，如果调用了**EXEC** or **DISCARD**，则没有必要再手动调用**UNWATCH** | always OK.                                                   |
| **MULTI**   | **MULTI**               | `显式`开启`redis事务`，后续`commands`将排队，等候使用**EXEC**进行原子执行 | always OK.                                                   |
| **EXEC**    | **EXEC**                | 执行事务中的`commands`队列，恢复连接状态。如果**WATCH**在之前被调用，只有`监测`中的`Keys`没有被修改，命令才会被执行，否则停止执行（详见下文，`CAS机制`） | **成功：** 返回数组 —— 每个元素对应着原子事务中一个 `command`的返回结果; **失败：** 返回`NULL`（`Ruby` 返回``nil``）; |
| **DISCARD** | **DISCARD**             | 清除事务中的`commands`队列，恢复连接状态。如果**WATCH**在之前被调用，`释放` `监测`中的`Keys` | always OK.                                                   |

`WATCH`命令的使用是为了解决 `事务并发` 产生的`不可重复读`和`幻读`的问题（简单理解为给`Key加锁`）