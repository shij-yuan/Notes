# AQS



**AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，即将暂时获取不到锁的线程加入到队列中**



### 两种资源共享方式

- **Exclusive**（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：

  - 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
  - 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的

- **Share**（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。



### 模板方法

```java
isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
```



## 独占获取同步状态

### acquire

该方法将会调用子类复写的 tryAcquire 方法获取同步状态，

- 获取成功：直接返回
- 获取失败：将线程封装在节点中，并将节点置于同步队列尾部，
    - 通过自旋尝试获取同步状态。如果在有限次内仍无法获取同步状态，该线程将会被 LockSupport.park 方法阻塞住，直到被前驱节点唤醒



## 共享获取同步状态

共享类型的节点获取共享同步状态后，如果后继节点也是共享类型节点，当前节点则会唤醒后继节点。这样，多个节点线程即可同时获取共享同步状态。





## Condition

### await


await 是一个响应中断的等待方法，主要逻辑流程如下：
1. 如果线程中断了，抛出 InterruptedException 异常
2. 将线程封装到节点对象里，并将节点添加到条件队列尾部
3. 保存并完全释放同步状态，保存下来的同步状态在重新竞争锁时会用到
4. 线程进入等待状态，直到被通知或中断才会恢复运行
5. 使用第3步保存的同步状态去竞争独占锁