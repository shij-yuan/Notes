# 线程池 

## 参数

**`ThreadPoolExecutor` 3 个最重要的参数：**

- **`corePoolSize` :** 核心线程数线程数定义了最小可以同时运行的线程数量。
- **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，信任就会被存放在队列中。

## 拒绝策略

- **`ThreadPoolExecutor.AbortPolicy`**：抛出 `RejectedExecutionException`来拒绝新任务的处理。
- **`ThreadPoolExecutor.CallerRunsPolicy`**：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。
- **`ThreadPoolExecutor.DiscardPolicy`：** 不处理新任务，直接丢弃掉。
- **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将丢弃最早的未处理的任务请求。



## execute( )

1. 判断核心线程数量
2. 判断工作队列是否满
3. adWorker( )，失败则拒绝策略

### addWorker

`Worker`是`ThreadPoolExecutor`中的内部类，继承自`AQS`且实现了`Runnable`接口。是一个可执行的`Runnable`对象。在`Worker`的构造函数中，使用线程工厂创建了一个线程，当`thread`启动的时候，会以`worker.run()`为入口启动线程，这里会直接调用到`runWorker()`中。



## submit( )

需要自己实现`Callable`接口的`call()`方法，`submit()` 提交任务到线程池，获取任务返回结果，返回结果是通过`FutureTask`来实现的。提交任务还是执行`execute()`方法，只是`task`被包装成了`FutureTask` ，也就是在`excute()`中启动线程后会执行`FutureTask.run()`方法。





## 有界队列

1. 当提交的任务数超过了corePoolSize，会将当前的任务提交到一个block queue中
2. 有界队列满了之后，如果 poolSize < maximumPoolsize，会尝试新建一个Thread进行处理
3. 若失败则拒绝



## 无界队列

1. 执行 execute 方法时，如果发现核心线程数已满，先执行 `workQueue.offer(command)` 来入列。
2. **队列也满了后，才会去创建新的非核心线程** 。（LinkedBlockingQueue如果用无参构造函数初始化，默认的容量是Integer.MAX_VALUE）

所以使用无界队列，会直接导致**最大线程数失效**。

