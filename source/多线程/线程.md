# 线程

## 创建线程方式

1. 继承Thread类，重写run方法，调用start( )
2. 实现Runnable接口，实现run方法，创建Thread并调用start( )
3. 实现Callable接口，实现call方法，作为`FutureTask<>`构造参数创建`FutureTask`对象，创建Thread实例并调用start( )
4. 创建Callable 或 Runnable任务，提交到线程池

## Thread

Thread实现了Runnable接口，并且实现了接口的run方法。

## Runnable

接口，只有一个run( )函数，**函数没有返回值**。

Runnable对象可以传入到Thread类的构造方法中，通过Thread来运行Runnable任务，而Callable接口则不能直接传入到Thread中来运行，Callable接口通常结合线程池来使用。

## Callable

接口，有call()函数，**call( )函数有返回值**。

## Future

Executor就是Runnable和Callable的调度容器，Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。可以直接通过get()函数获取执行结果，该函数会**阻塞**，直到结果返回。

## FutureTask

FutureTask则是一个RunnableFuture<V>，而RunnableFuture实现了**Runnbale**又实现了**Futrue<V>**这两个接口。

FutureTas实现了run 方法，调用了构造函数传入的Callable实现类的call方法，并且用result的变量接收方法的返回值，最后调用set方法将返回结果设置到类的属性。可以实现获取返回值以及判断线程是否运行完成、取消的能力。



## start( ) 和 run( )

### start

启动一个**新线程**，处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行相应线程的run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止。start()不能被重复调用。用start方法来启动线程，真正实现了多线程运行。

### run

run()就和普通的成员方法一样，可以被重复调用。如果直接调用run方法，并**不会启动新线程**。程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行。