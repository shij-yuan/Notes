# HashMap

HashMap 初始容量是16，负载因子为 0.75

## 查找

1. (n - 1) & hash 计算出桶的位置

    ```java
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
    ```

    高位数据与低位数据进行异或，以此加大低位信息的随机性

2. 遍历链表、红黑树查找

## 遍历

会先遍历桶数组，找到包含链表节点，然后遍历该桶所指向的链表。然后继续寻找下一个不为空的桶

## 插入

1. 定位要插入的键值对属于哪个桶
    - 桶空，当桶数组 table 为空时，通过扩容的方式初始化 table
2. 查找链表中，要插入的键值对是否已存在。若存在且不同，则覆盖；不存在，则插入。并根据链表长度决定是否将链表转为红黑树
3. 判断键值对数量是否大于阈值，大于的话则进行扩容操作

## 扩容

条件：HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容

1. 计算新桶数组的容量 newCap 和新阈值 newThr （ **扩大两倍**）
2. 创建新的桶数组
3. 将键值对节点重新映射到新的桶数组里。对于树形节点，需先拆分红黑树再映射。对于链表类型节点，则需先对链表进行分组，然后再映射。



## 树化

1. 链表长度大于等于 TREEIFY_THRESHOLD （**默认为8**）
2. 桶数组容量大于等于 MIN_TREEIFY_CAPACITY
    当桶数组容量比较小时， 优先扩容，避免一些列的不必要的树化



## 其他

桶数组 table 被申明为 transient，不会被默认的序列化机制序列化

1. table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间
2. 同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误。







## 哈希冲突

Set集合调用 `add`方法时：

1. 调用元素的`hashCode`方法，判断哈希值是否存在相等
2. 若相等，则调用`equals`方法进行比较
3. 若返回`true`则两个元素相同，不添加到`Set`中


