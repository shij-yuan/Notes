# G1垃圾回收器

## G1 回收器： 区域化、分代式回收器

因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域(Region) (物理 上不连续的)。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。

G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。**G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。**

由于这种方式的侧重点在于回收垃圾最大量的区间(Region) ，所以 垃圾优先(Garbage First) 。

### 优点

- 并行与并发
  
    - 并行性: G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
- 并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况
  
- 分代收集

    - 从分代上看，**G1依然属于分代型垃圾回收器**，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。
    - 将**堆空间分为若干个区域(Region) ,这些区域中包含了逻辑上的年轻代和老年代。**
    - 和之前的各类回收器不同，它同时**兼顾年轻代和老年代**。对比其他回收器，或者工作在年轻代，或者工作在老年代

- 空间整合

    - CMS  “标记-清除”算法 + 内存碎片 + 若干次GC后进行一次碎片整理

    - G1将内存划分为若干个region。 内存的回收是以region作为基本单位的。**Region之间是复制算法，但整体上实际可看作是标记-压缩(Mark-Compact)算法**，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

- 可预测的停顿时间模型 (即:软实时soft real-time)

    这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿：时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

    - 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。

    - G1跟踪各个Region里面的垃圾堆积的价值大小 (回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，**每次根据允许的收集时间，优先回收价值最大的Region**。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。

    - 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。



### Region

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gewpao9yowj31ac0fqqb5.jpg)

使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB, 2MB, 4MB, 8MB, 16MB, 32MB。可以通过-XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。

虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region (不需要连续)的集合。通过Region的动态分配方式实现逻辑上的连续。



### 回收过程

主要包括三个过程

- 年轻代 GC （Young GC）
- 老年代并发标记过程 （Concurrent marking）
- 混合回收 （Mixed GC）

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gewpgbdbqtj31i40hmn33.jpg)



应用程序分配内存，**当年轻代的Eden区用尽时开始年轻代回收过程**; G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。**然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。**

当堆内存使用达到一定值(默认45%)时，开始老年代并发标记过程。

标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他Gc不同，**G1的老年代回收器不需要整个老年代被回收，一次只需要扫描 / 回收小部分老年代的Region就可以了**。同时，这个老年代Region是和年轻代一起被回收的。

> 例子: 一个web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45号，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。



### 年轻代 GC YoungGC

JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。

**年轻代垃圾回收只会回收Eden区和Survivor区。**

YGC时，首先G1停止应用程序的执行 (Stop-The-World) ，G1创建回收集(Collection Set)，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。



### 回收过程一：年轻代 GC YoungGC（STW）

- **第一阶段，扫描根**
    根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。

- **第二阶段，更新RSet**
    处理dirty card queue中的card，更新RSet。 此阶段完成后，**RSet可以准确的反映老年代对所在的内存分段中对象的引用。**
- **第三阶段，处理RSet。**
    识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。

- **第四阶段，复制对象。**
    此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段， Survivor 区内存分段中存活的对象如果年龄未达阈值，年龄会加1，如果达到阀值会被会被复制到 old 区中空的内存分段。如果Survivor空间不够，Eden空间的 部分数据会直接晋升到老年代空间。

- **第五阶段，处理引用。**
    处理Soft，Weak， Phantom, Final, JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。

### 回收过程二：老年代并发标记过程 （Concurrent marking）

1. **初始标记阶段**（**STW**）: 标记从根节点直接可达的对象。这个阶段是**STW**的，并且会触发一次年轻代GC。
2. **根区域扫描**(Root Region Scanning) : G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。
3. **并发标记**(Concurrent Marking): 在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被youngGC中断。在并发标记阶段，**若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收**。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。
4. **再次标记**(**STW**): 由于应用程序持续进行，需要修正上一次的标记结果。是STW 的。G1中采用了比CMS更快的初始快照算法: snapshot-at-the-beginning (SATB)。
5. **独占清理 **(**STW**): 计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。 
    - 这个阶段并不会实际上去做垃圾的收集
6. **并发清理阶段**: 识别并清理完全空闲的区域。



### 回收过程三：混合回收 （Mixed GC）

当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC， 该算法并不是一个Old GC，除了回收整个Young Region,还会回收一部分的Old Region。

> 这里需要注意:是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。

并发标记结束以后，**老年代中100%为垃圾的内存区域被回收**了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次(可以通过-XX:G1MixedGCCountTarget设置)被回收。

混合回收的回收集(Collection Set) 包括八分之一的老年代内存分段，Eden区内存分段，Survivor区 内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。

由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，-XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。

混合回收并不一定要进行8次。有一个阈值 -XX : G1HeapWastePercent, 默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。



### 回收过程四 full GC（可能的）

G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行(Stop-The-World) ，使用**单线程**的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢?比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc，这种情况可以通过增大内存解决。

导致G1 Full GC的原因可能有两个:

1. Evacuation回收阶段的时候没有足够的 to-space来存放晋升的对象;
2. 并发处理过程完成之前空间耗尽。





### 记忆集 remembered set

解决的问题：一个对象被不同区域引用的问题：一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确?

在其他的分代收集器，也存在这样的问题 (而G1更突出)：**回收新生代也不得不同时扫描老年代**，这样的话会降低Minor GC的效率。

**解决方法:**

无论G1还是其他分代收集器，JVM都是使用Remembered Set 来**避免全局扫描**:

- 每个Region都有一个对应的Remembered Set;
- 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作;
- 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region (其他收集器:检查老年代对象是否引用了新生代对象) ;
- 如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中;
- 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set; 就可以保证不进行全局扫描，也不会有遗漏。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gexprqis0sj31j60iun5h.jpg)





### 优化

1. 避免设置年轻代大小，使用默认
2. 暂停时间不能太严苛，导致吞吐量下降



### 参数设置

- -XX: G1HeapRegionSize
    设置每个Region的大小。值是2的幂，范围是1MB 到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的 1 /2000。

- -XX : MaxGCPauseMillis
    设置期望达到的最大GC停顿时间指标(但不保证达到)。默认值是200ms
- -XX: ParallelGCThread
    设置STW工作线程数的值。最多设置为8 
- -XX: ConcGCThreads
    设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。
- -XX: InitiatingHeapOccupancyPercent
    设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。