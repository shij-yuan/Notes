# 运行时数据区



一个进程中，线程共享：**方法区、 堆**； 
各自独立： 虚拟机栈， 本地方法栈， PC计数器

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gizdns7b2yj30kj0km0tg.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ggjlqme6t1j30ru0g3t9w.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gesz6gsmslj31q20qstq1.jpg)

## 程序计数寄存器

程序计数器(Program Counter Register)是一块较小的内存空间，私有的，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是**通过改变这个计数器的值来选取下一条需要执行的字节码指令**，它是**程序控制流的指示器**，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

唯一在`Java`虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。

![](https://s1.ax1x.com/2020/04/22/JUe90K.png)

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地 址;如果正在执行的是本地(N at ive)方法，这个计数器值则应为空(Undefined)

1. 使用PC寄存器存储字节码指令地址有什么用呢? 为什么使用PC寄存器记录当前线程的执行地址呢?

    因为CPU需要不停的切换各个线程,这时候切换回来以后,就得知道接着从哪开始继续执行。
    JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

2. PC寄存器为什么会被设定为线程私有?

    所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法, CPU会不停地做任务切换, 这样必然导致经常中断或恢复。
    **为了能够准确地记录各个线程正在执行的当前字节码指令地址, 最好的办法是为每一个线程都分配一个PC寄存器**,这样一来各个线程之间便可以进行独立计算,从而不会出现相互干扰的情况。
    由于CPU时间片轮限制,众多线程在并发执行过程中,任何一个确定的时刻,一个处理器或者多核处理器中的一个内核,只会执行某个线程中的一条指令。这样必然导致经常中断或恢复,如何保证分毫无差呢?每个线程在创建后,都会产生自己的程序计数器和栈帧,程序计数器在各个线程之间互不影响。



## JAVA虚拟机栈

**线程私有的**，它的生命周期与线程**相同**。**不需要GC**

虚拟机栈描述的是Java方法执行的线程内存模型: 每个方法被执行的时候，Java虚拟机都 会同步创建一个**栈帧**用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

### 可能的异常

- 如果线程请求的栈深度大于虚 拟机所允许的深度，将抛出`StackOverflowError`异常
- 如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出`OutOfMemoryError`异常。



## 本地方法栈

与虚拟机栈所发挥的作用是非常相似的，其区别只是**虚拟机栈为虚拟机执行Java方法(也就是字节码)服务**，而**本地方法栈则是为虚拟机使用到的本地(Native) 方法服务**。**不需要GC。**



## 栈运行原理

不同线程中所包含的栈帧是不允许存在相互引用的,即不可能在一个栈帧之中引用另外一个线程的栈帧。如果当前方法调用了其他方法,方法返回之际,当前栈帧会传回此方法的执行结果给前一个栈帧,接着,虚拟机会丢弃当前栈帧,使得前一个栈帧重新成为当前栈帧。
Java方法有两种返回函数的方式,一种是**正常的函数返回**,使用 return指令;另外一种是**抛出异常**。不管使用哪种方式,都会导致栈帧被弹出。

### 栈帧内部

**局部变量表**(Local Variables)

- 局部变量表是一组**变量值**的存储空间，存放了编译期可知的各种Java虚拟机基本数据类型(boolean、byte、char、short、int、 float、long、double)、对象引用(reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和 returnAddress 类型(指向了一条字节码指令的地址)。

- 这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。这里说的“大小”是指变量槽的数量

**操作数栈**( Operand stack)  (或表达式栈)

- 操作数栈,主要用于保存计算过程的中间结果,同时作为计算过程中变量临时的存储空间。
- 操作数栈就是JM执行引擎的一个工作区,当一个方法刚开始执行的时候, 一个新的栈帧也会随之被创建出来,这个方法的操作数栈是空的。
- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值,其所需的最大深度在编译期就定义好了,保存在方法的Code属性中,为 max stack的值。
- 栈中的任何一个元素都是可以任意的Java数据类型。32bit的类型占用一个栈单位深度，64bit的类型占用两个栈单位深度
- 操作数栈并非采用访问索引的方式来进行数据访问的,而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问
- 如果被调用的方法带有返回值的话,其返回值将会被压入当前栈帧的操作数栈中,并更新PC寄存器中下一条需要执行的字节码指令。
- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配,这由编译器在编译器期间进行验证,同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。
- 另外,我们说Java虚拟机的解释引擎是基于栈的执行引擎,其中的栈指的就是操作数栈。

**动态链接**( Dynamic Linking)  (或指向运行时常量池的方法引用)

- 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接( Dynamic Linking)。比如: invokedynamic指令
- 在Java源文件被编译到字节码文件中时,所有的变量和方法引用都作为符号引用( Symbolic Reference)保存在class文件的常量池里。比如: 描述一个方法调用了另外的其他方法时,就是通过常量池中指向方法的符号引用来表示的,那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

**方法返回地址**( Return address)  (或方法正常退出或者异常退出的定义)

一些附加信息



### 方法的调用

在JVM中,将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

- 静态链接
    当一个字节码文件被装载进JⅦM内部时,如果被调用的目标方法在编译期可知且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。
- 动态链接:
    如果被调用的方法在编译期无法被确定下来,也就是说,只能够在程序运行期将调用方法的符号引用转换为直接引用,由于这种引用转换过程具备动态性,因此也就被称之为动态链接。

非虚方法： 如果方法在编译期就确定了具体的调用版本,这个版本在运行时是不可变的。这样的方法称为非虚方法。

- 静态方法、私有方法、 final方法、实例构造器、父类方法都是非虚方法。
- 其他方法称为虚方法。



### 虚拟机中提供了以下几条方法调用指令

普通调用指令

1. invokestatic:调用静态方法,解析阶段确定唯一方法版本

2. invokespecial:调用`<init>`方法、私有及父类方法,解析阶段确定唯一方法版本

3. invokevirtual:调用所有虚方法

4. invokeinterface:用接口方法

动态调用指令
5. invokedynamic: 动态解析出需要调用的方法,然后执行

前四条指令固化在虚拟机内部,方法的调用执行不可人为干预,而 invokedynamic指令则支持由用户确定方法版本。**其中 invokestatic指令和 invoke special 指令调用的方法称为非虚方法,其余的 ( final 修饰的除外 )称为虚方法**



### Java语言中方法重写的本质

1. 找到操作数栈栈顶元素所指对象的实际类型，记做C

2. 如果在类型C中找到和常量池中的描述符相同的方法，则进行访问权限的校验，如果校验通过返回这个方法的直接引用，查找过程结束；如果不通过，返回`java.lang.IllegalAccessError`异常

3. 否则，按照继承关系从下往上依次对C的各个父类执行搜索和验证过程

4. 如果没有找到合适的方法，抛`java.lang.AbstractMethodError`异常

    
