# HTTP 

## 状态码

### `1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

### `2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。

「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。

「**206 Partial Content**」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

### `3xx` 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。

「**302 Moved Temporarily**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

### `4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。

「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。

「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

### `5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。

「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。

「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。

「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。



## 字段

1. Host : 客户端发送请求时，用来指定服务器的域名。
2. Content-Length : 服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。
3. Connection  ：最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。
4. Content-Type  ：用于服务器回应时，告诉客户端，本次数据是什么格式。
5. Last-Modified：资源的最后修改日期时间
6. Accept：可处理的媒体类型
7. User-Agent：HTTP 客户端程序的信息



## HTTP 1.1 缺点

无状态 ： cookie

明文传输



## HTTPS

1. 混合加密：防止窃听

	- 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
    - 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。
2. 摘要算法：防止篡改

    - **摘要算法**用来实现**完整性**，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险
3. 数字证书：防止伪装
    - 通过第三方机构

### 证书签发流程

1. 生成密钥对，将私钥自己保存，公钥和网站域名等信息提交给CA
2. CA把证书签发机构、证书有效期、网站的公钥、网站域名等信息以**明文**形式写入到一个文本文件
3. CA选择一个**指纹算法**(一般为hash算法)计算文本文件的内容得到**指纹**，用CA的**私钥**对**指纹**和**指纹算法**进行加密得到**数字签名**，签名算法包含在证书的**明文**部分
4. CA把明文证书、指纹、指纹算法、数字签名等信息打包在一起得到证书下发给服务器

### 加密通信流程

1. 客户端发起 HTTPS 请求
2. 服务端返回证书
3. 客户端验证证书：根据**签名算法**对**数字签名**解密得到**证书指纹**和**指纹算法**，对比
4. 客户端使用伪随机数生成器生成对称密钥，然后用证书的公钥加密这个对称密钥
5. 服务端使用自己的私钥解密，得到对称密钥
6. 开始通信

公钥不需安全性，对称密钥都是临时生成且随机的。

![](http://emall-t.oss-cn-hangzhou.aliyuncs.com/blog/2020-07-06-044235.png)



## HTTP 1.0

- 使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
- 支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。



## HTTP 2.0

### 二进制分帧层

HTTP 1.x在应用层以纯文本的形式进行通信，而HTTP 2.0将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。所有同主机的通信能够**在一个TCP连接**上完成。

### 通信单位

- 帧

    HTTP 2.0通信的最小单位，包括帧首部、流标识符、优先值和帧净荷等。 

    - **DATA**：用于传输HTTP消息体；
    - **HEADERS**：用于传输首部字段；
    - **SETTINGS**：用于约定客户端和服务端的配置数据。比如设置初识的双向流量控制窗口大小；
    - **WINDOW_UPDATE**：用于调整个别流或个别连接的流量

- 消息

    消息是指逻辑上的HTTP消息（请求 / 响应）。**一系列数据帧组成了一个完整的消息**

- 流

    流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。 
    所有HTTP 2. 0 通信都在一个TCP连接上完成， 这个连接可以承载任意数量的双向数据流Stream。 相应地， 每个数据流以 消息的形式发送， 而消息由一 或多个帧组成， 这些帧可以乱序发送， 然后根据每个帧首部的流标识符重新组装。 

### 多路复用

基于二进制分帧层，HTTP 2.0可以在共享TCP连接的基础上，同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发送出去，最后在另一端根据流ID和首部将它们重新组合起来。 

HTTP 2.0建立一条TCP连接后，并行传输着3个数据流，客户端向服务端乱序发送stream1~3的一系列的DATA帧，与此同时，服务端已经在返回stream 1的DATA帧 

![](http://emall-t.oss-cn-hangzhou.aliyuncs.com/blog/2020-07-06-044318.jpg)

*头部压缩* ： HTTP/2 会**压缩头**（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的分**。



## HTTP 3.0
HTTP 3.0 是基于 UDP 协议的 QUIC 协议。
一次TCP连接中，如果出现了丢包的情况，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。

### 0-RTT
通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。

### 多路复用
QUIC 原生就实现多路复用，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求，一个连接上的多个 stream 之间没有依赖，丢包后不影响其他传输。

### 头部加密

### 向前纠错
每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。